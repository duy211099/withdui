---
title: 4. Giải pháp tổng quan để tách biệt core code và infrastructure code
slug: giai-phap-tong-quan-de-tach-biet-core-code-va-infrastructure-code
date: '2025-12-21'
excerpt: ''
category: Web Architecture
tags: ["KIẾN TRÚC ỨNG DỤNG WEB - Nguyễn Thế Huy", "1-Core Code & Infrastructure Code"]
author: huynt.dev
published: true
featured_image: ''
---

Làm thế nào để đạt được sự tách biệt? Về mặt kiến trúc, mục tiêu này thường được hiện thực hóa thông qua các lớp (layer) và các mẫu thiết kế phù hợp. Một số nguyên tắc và kỹ thuật tổng quan bao gồm:
- Sử dụng Dêpndency Injection và Inversion of Control: Thay vì để code lõi tự mình khởi tạo hoặc gọi trực tiếp các thành phần hạ tầng, ta đảo ngược sự phụ thuộc: phần core định nghĩa các giao diện (interface) mà nó cần (ví dụ interface OrderRepo, SendGridMailer,...) Tại run time, ta inject implementation hạ tầng vào core code thông qua constructor hoặc contrainer của framework. Nhờ đó, core code chỉ biết đến abstraction, không biết chi tiết cụ thể bên ngoài là gì. Đây là ứng dụng nguyên lý Dependency Inversion (DIP) và là chìa khóa để tách core/infra.
- Phân tầng kiến trúc rõ ràng: Code được tổ chức thành các tầng như đã đề cập (Domain, Application, Infrastructure). Tầng Domain chứa các Entity, Value Object, Domain Service... thuần túy, không dính dáng framework. Tầng Application điều phối các use case, phối hợp domain với hạ tầng (qua interface): thường chính là các Application Service hay service lớp ứng dụng. Tầng Infrastructure chứa các Adapter cụ thể: ví dụ lớp repository cụ thể dùng Eloquent, lớp gửi email SMTP, lớp controller framework,... Luồng phụ thuộc một chiều: Domain không phụ thuộc ai, Application phụ thuộc Domain, Infrastructure phụ thuộc cả Domain (để biết interface) và có thể phụ thuộc framework. Kiến trúc này thường gọi là layered architecture. Nó đảm bảo core code nằm ở trung tâm và hạ tầng ở rìa, đúng tinh thần 'onion architecutre' hay 'hexagonal architecture'.
- Áp dụng các mẫu thiết kế thích hợp: Nhiều design patttern kinh điển hỗ trợ việc tách biệt này. Ví dụ: Repository Pattern giúp trừu tượng hóa việc truy xuất và lưu trữ dữ liệu domain, ngăn cách giữa domain và CSDL. Domain Model pattern giúp tập trung logic nghiệp vụ vào các đối tượng domain thay vì rải rác hoặc dùng cấu trúc bảng thuần. Dependency Injection (thực chất là một kỹ thuật hơn là pattern) giúp cấu hình các phụ thuộc. Factory Pattern đôi khi dùng để tạo ra đối tượng thay vì gọi trực tiếp hàm của thư viện bên ngoài (ví dụ tạo đối tượng thời gian hiện tại thông qua một Clock interface, thay vì gọi new DateTime() trong core code - giúp test dễ dàng và tách biệt với hệ thống thời gian)
- Che giấu chi tiết hạ tầng sau các abstract interface: Mọi tương tác ra bên ngoài (IO, DB, HTTP request, file,...) nên được đóng gói sau một lớp trừu tượng. Code core chỉ gọi phương thức của lớp trừu tượng đó, không quan tâm cách thực hiện. Ví dụ, thay vì trong code domain gọi trực tiếp PDO để query DB, ta định nghĩa một interface OrderRepository với method save(order). Triển khai cụ thể MySqlOrderRepo sẽ dùng PDO hay Query Builder gì đó để lưu, nhưng code domain hoàn toàn không biết - nó chỉ là 'đơn hàng đã được lưu'. Bằng cách che giấu chi tiết, ta đạt được sự đa hình: có thể có nhiều triển khai repository khác nhau (DB khác, hay giải lập in-memory để test) mà domain code không đổi gì.
- Tách riêng phần đặc thù framework: Framework (như Laravel) thường gộp cả xử lý HTTP, Routing, ORM... tức là vừa có phần kết nối (routing, controller nhận request) vừa có phần truy cập DB (Eloquent). Để tách biệt, ta nên giới hạn phần phụ thuộc framework ở rìa ứng dụng. Ví dụ: Controller Lẩvel chỉ nên đóng vai trò chuyển tiếp dữ liệu request vào lớp Application Service (thuộc core code) và trả response. Các model Active Record nếu sử dụng, nên được bao hoặc ánh xạ sang Entity thuần của domain để tránh đưa thẳng Eloquent khắp nơi. Càng ít code 'Laravel' xuất hiện trong logic domain càng tốt: khi đó nếu mai này chuyển sang framework khác, domain code vẫn có thể giữ nguyên, chỉ cần viết lớp kết nối mới. Tương tự, các Facade hay Helper toàn cục không nên được gọi trực tiếp trong core code; thay vào đó, nên truyền chugns vào qua interface nếu thật sự cần thiết.

> Tóm lại, giải pháp là tạo ra một ranh giới rõ ràng (boundary) giữa ứng dụng của ta và thế giới bên ngoài. Thế giới bên ngoài bao gồm: framework, CSDL, hệ thống tệp, dịch vụ khác,... Phần giao tiếp qua lại với ranh giới đó chính là infrastructure code - ta giữ nó tách khỏi phần logic bên trong. Ranh giới này đôi khi được ví như 'Ports and Adapters': core code cung cấp các 'port' (cổng kết nối - thường là các interface), còn infrastucture code là các 'adapter' cắm vào các 'port' (cổng kết nối - thường là các interface), còn infrastucture code là các 'adapter' cắm vào cổng đó để thực hiện công việc cụ thể. Kiểu kiến trúc này sẽ cho phép chúng ta hoán đổi adapter dễ dàng, ví dụ thay storage, thay phương thức giao tiếp, mà không làm xáo trộn code lõi.



